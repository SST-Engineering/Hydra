<h2>load_from_state</h2>
Function that is passed a structured parameter to 
<ul><li>Open a destination db table</li>
<li>Run a set of regular expressions, or run a state-machine</li>
<li>Insert each record into the detsination db table</li></ul>
Return: false on failure, number of records read and inserted on success<br>

Call of the form <br><code>
$records_loaded = load_from_state($p);<br>
if $records_loaded is false then console("Fails in load_from_state,"+last_error());<br>
else console("Success in loading {$records_loaded} records");<br>
</code>
<br><br>
Where $p is this structure:<br><br>
<table class="alc-help" >
<tr><th>Property Name</th><th>Can be Null or Missing</th><th>Default value taken if Null or Missing</th><th>Example of setting</th></tr>
   <tr><td>use_db_connect </td><td>No</td><td> <u><i><b>Must be set to a valid value</b></i></u> </td><td>$p.use_db_connect = "ICE_DWH"</td></tr>
   <tr><td>use_db_table</td><td>No</td><td> <u><i><b>Must be set to a valid value</b></i></u> </td><td>$p.use_db_table = "STG_Bank_Tbl"</td></tr>
   <tr><td>file_to_read</td><td>No</td><td> <u><i><b>Must be set to a valid value</b></i></u> </td><td>$p.file_to_read = $file_to_read</td></tr>
   <tr><td>file_field_lookup</td><td>Yes</td><td>Null, no source to destination translation lookup, all fields in the source are written to destination</td><td>$p.file_field_lookup = $file_field_lookup</td></tr>
   <tr><td>file_add_fields</td><td>Yes</td><td>Null, no fields added to destination, otherwise these fields added</td><td>$p.file_add_fields = $file_add_fields</td></tr>
   <tr><td>file_field_process</td><td>Yes</td><td>Null, no value adjust on any fields, otherwise field names in these properties are processed</td><td>$p.file_field_process = $file_field_process</td></tr>
   <tr><td>file_not_null_fields</td><td>Yes</td><td>Null, null fields are inserted, otherwise fields in these properties are checked for null</td><td>$p.file_not_null_fields = $file_not_null_fields</td></tr>
   <tr><td>verbose</td><td>Yes</td><td>false, otherwise output debug trace code</td><td>$p.verbose = true</td></tr>
   <tr><td>checksum_field</td><td>Yes</td><td>null, otherwise the name of the source column name to use as the checksum field</td><td>$p.checksum_field = "ACC NO";</td></tr>
   <tr><td>guid</td><td>Yes</td><td>null, otherwise obtained from guid() and used as processId (typically)</td><td>$p.guid = $guid;</td></tr>
   <tr><td>custom_regex</td><td>Yes</td><td>null, a structured list of regular expressions </td><td>$custom_regx.0="[\w]{1,}";<br>$p.custom_regx = $custom_regx;</td></tr>
   <tr><td>use_state</td><td>Yes</td><td>null, the Name of the state machine defined </td><td>state SM step * then S1 when "pattern";<br>$p.use_state = "SM";</td></tr>
   <tr><td>emit_on_state</td><td>Yes</td><td>null, when using a state machine, the state when a record is ready for insertion </td><td>$p.emit_on_state = "EmitRecord";</td></tr>
</table>
<br>
Then there are some <b>"callback"</b> functions, callback means that the loader will call these functions (if they exist) in the profile alcode.alc
<ul>
<li><b> function file_custom_validate </b>(<i>db_field_name</i>,<i>proposed value</i>) - return the validated value for this field, or exit inside the function</li>

<li><b> function file_conditional_insert </b>(<i>record</i>) - last chance to abort this insert, return false to abort (skip) this record</li>

<li><b> function file_custom_fields </b>(<i>record</i>) - make any final changes to the fields in this record, maybe set a field by calculation of other fields</li>
</ul>


